# 计算机网络  

## OSI七层模型  
**应用层**  
网络服务与最终用户的一个接口。  
协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP  
**表示层**  
数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）  
格式有，JPEG、ASCll、DECOIC、加密格式等  
**会话层**  
建立、管理、终止会话。（在五层模型里面已经合并到了应用层）  
对应主机进程，指本地主机与远程主机正在进行的会话  
**传输层**  
定义传输数据的协议端口号，以及流控和差错校验。  
协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层  
**网络层**  
进行逻辑地址寻址，实现不同网络之间的路径选择。  
协议有：ICMP IGMP IP（IPV4 IPV6）  
**数据链路层**  
建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）  
将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。  
**物理层**  
建立、维护、断开物理连接。（由底层网络定义协议）  


## HTTP  
**HTTP是基于TCP/IP协议的应用层协议。它不设计数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口**  

**HTTP1.0**  
**HTTP/1.0 版的主要缺点**是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接
TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送 速率较慢（slow start）。所以。HTTP/1.0版本的**性能比较差**。随着网页加载的外部资源越来越多，这个问题就愈发突出了  


**HTTP1.1**  
**持久连接（persistent connection）**  
最大的变化，就是引入了持久连接,即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive  
客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接  

**管道机制（pipelining）**  
1.1版还引入了管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率  
距离来说，客户端需要请求两个资源。以前的做法是，同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后在发出B请求。管道机制允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。  

**分块传输编码**  
产生一块数据，就发送一块，采用“流模式”(stream)取代“缓存模式”(buffer)  
因此，1.1版本可以不使用Content-Length字段，而是用"分块传输编码"（chunked transfer encoding）  
 
**缺点**  
虽然1.1版本允许复用TCP连接，但是同一个TCP连接里面，所有的**数据通信是按次序进行**。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）  
为了避免这个问题，只有两种方法：  
**一是减少HTTP请求数，二是同时多开TCP持久连接。**  
这引出了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。




**HTTP2.0**  
**多工**
HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。  
举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。  
这样双向的、实时的通信，就叫做多工（Multiplexing）。  
**服务器推送**
HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。  
常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了  


**总结**
* HTTP/0.9 客户端只能发送get请求，服务端只能响应HTML文件
* HTTP/1.0 多了POST和HEAD请求，头信息多了Content-type、Content-Encoding等有用的字段，明显的缺点是一次TCP连接只能发送一次请求
* HTTP/1.1 持久连接、管道机制、 Content-Length字段、分块传输编码、HOST字段、多个请求方法，明显的缺点是“队头阻塞”
* HTTP/2 二进制协议、多工通信、数据流、头信息压缩、服务器推送

<br/>

**状态码**  
HTTP状态码：当用户访问一个网页时，浏览器会向网页所在的服务器出请求，当浏览器接收并显示网页前，此网页所在服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求  
**HTTP状态码用于描述服务器对请求的处理结果**  

HTTP状态码分类：  
（1）1**：信息，服务器收到请求，需要请求者继续执行操作

（2）2**：成功，操作被成功接收并处理

（3）3**：重定向，需要进一步的操作以完成请求

（4）4**：客户端错误，请求包含语法错误或者无法完成请求

（5）5**：服务器错误，服务器在处理请求的过程中发生了错误

常见的HTTP状态码：
* 200——OK，请求成功
* 204——请求被受理但没有资源可以返回
* 206——客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源
* 301——Moved Permanently，资源（网页等）被永久转移到其他URL
* 302——Found，307——Temporary Redirect，临时重定向，请求的文档被临时移动到别处
* 304——Not Modified，未修改，表示客户端缓存的版本是最近的
* 400——请求报文语法有误，服务器无法识别
* 401——Unauthorized，请求要求用户的身份认证
* 403——Forbidden，禁止，服务器理解客户端请求，但是拒绝处理此请求，通常是权限设置所致
* 404——Not Found，请求的资源（网页等）不存在
* 500——Internal Server Error——内部服务器错误
* 502——Bad Gateway，充当网关或代理的服务器从远端服务器接收到了一个无效的请求
* 503——服务器超过最大负荷
* 504——Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求




## TCP  
3次握手/4次挥手  
三次握手的必要性：为了保证服务器能接收到客户端的信息并做出正确的应答而进行前两次（第一次和第二次）握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次（第二次和第三次）握手。  
![](tcp.png)

（1）ACK：TCP规定，只有当ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1

（2）SYN（SYNchronization）：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这个是一个连接请求报文。对方若同意建立连接，则响应报文中SYN=1，ACK=1。因此，SYN置1表示这是一个连接请求或连接接受报文。

（3）FIN（finish）：终结的意思，用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并请求释放连接。

**三次握手说明**

（1）第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置1，序列号seq（sequence number）为x；然后，客户端进入SYN_SEND状态，等待服务器的确认。

（2）第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，ACK位置1，确认号ack（acknowledgement number）为x+1；同时，自己还要发送SYN请求信息，将SYN位置1，序列号seq为y；服务器将上述SYN+ACK报文段一并发送给客户端，此时服务器进入SYN_RECV状态。

（3）第三次握手：客户端收到服务器的SYN+ACK报文段。然后将确认号ack设置为y+1，向服务器发送ACK报文段。这个报文段发送完毕后，客户端和服务器都进入ESTABLISHED状态，完成TCP三次握手，之后可以开始传数据。

**四次挥手**  
当客户端和服务器通过三次握手建立了TCP连接之后，当数据传输完毕，就要断开TCP连接，这个过程称为四次挥手。四次挥手说明：

（1）第一次挥手：主机1（可以是客户端，也可以是服务器）设置序列号seq为u，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT状态，这表示主机1没有数据要发送给主机2了。

（2）第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回复一个ACK报文段，确认号ack为u+1，序列号seq为v；主机2进入CLOSE_WAIT状态；主机1收到主机2发送的ACK报文段之后，进入FIN_WAIT_2状态。

（3）第三次挥手：主机2向主机1发送FIN报文段，设置序列号seq为w，确认号ack为u+1，请求关闭连接，同时主机2进入LAST_ACK状态

（4）第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，确认号ack为w+1，序列号seq为u+1，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL（MSL，最长报文段寿命）后依然没有收到回复，则证明服务端已经正常关闭，那么主机1也可以关闭连接了。

滑动窗口  
    慢启动/拥塞控制  




可靠通信  
    TCP状态机  




## UDP  

**TCP和UDP的区别**
TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来  
UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境  



## WebSocket   


## 典型问题
>**一次完整的HTTP事务是怎样一个过程**  
1） 域名解析  
2） 发起TCP的3次握手  
3） 建立TCP连接后发起http请求  
4） 服务器响应http请求，浏览器得到html代码  
5） 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）  
6） 浏览器对页面进行渲染呈现给用户  

>**常见的HTTP方法有哪些**  
>* GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
>* POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
>* PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
>* HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
>* DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
>* OPTIONS：查询相应URI支持的HTTP方法

>**HTTP与HTTPS的区别**  
>* HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
>* HTTP 是不安全的，而 HTTPS 是安全的
>* HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
>* 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
>* HTTP 无法加密，而HTTPS 对传输的数据进行加密
>* HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书

>**说说304缓存的原理**  
>* 服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存  
>* 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件  
>* 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体  











